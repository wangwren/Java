# 通过异常处理错误

## 基本异常

**异常情形**是阻止当前方法或作用域继续执行的问题。把异常情形与普通问题相区分很重要。所谓普通问题是指，在当前环境下能得到足够的信息，总能处理这个错误。而对于异常情形，就不能继续下去了，因为在当前环境下无法获得必要的信息来解决问题。你所能做的就是从当前环境跳出，并且把问题提交给上一级环境。这就是抛出异常时所发生的事情。

当抛出异常后，有几件事会随之发生。首先，同Java中其他对象的创建一样，将使用 new 在堆上创建异常对象。然后，当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用。此时，异常处理机制接管程序，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是**异常处理程序**，它的任务是将程序从错误状态中恢复，以使程序要么换一种方式运行，要么继续运行下去。

举一个抛出异常的简单例子。对于对象引用 t ，传给你的时候可能尚未被初始化。所以在使用这个对象引用调用其方法之前，会先对引用进行检查。可以创建一个代表错误信息的对象，并且将它从当前环境中“抛出”，这样就把错误信息传播到了“更大”的环境中。这被称为**抛出一个异常**，看起来像这样：

```java
if(t == null)
    throw new NullPointerException();
```

这就抛出了异常，于是在当前环境下就不必再为这个问题操心了。

### 异常参数

与使用Java中的其他参数对象一样，我们总是用 new 在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个构造器：一个是默认构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：

```java
throw new NullPointException("t = null");
```

要把这个字符串的内容取出来可以有多重不同的方法。

关键字 throw 将产生许多有趣的结果。在使用 new 创建了异常对象之后，此对象的引用将传给throw。尽管返回的异常对象其类型通常与方法设计的返回类型不同，但从效果上看，它就像是从方法“返回”的。可以简单地把异常处理看成一种不同的返回机制，当然若过分强调这种类比的话，就会有麻烦了。**另外还能用抛出异常的方式从当前的作用域退出**。在这两种情况下，将会返回一个异常对象，然后退出方法或作用域。

此外，**能够抛出任意类型的 Throwable 对象，它是异常类型的根类。通常，对于不同类型的错误，要抛出相应的异常**。错误信息可以保存在异常对象内部或者用异常类的名称来暗示，上一层环境通过这些信息来决定如何处理异常。（通常，异常对象中仅有的信息就是异常类型，除此之外不包含任何有意义的内容。）

## 捕获异常
要明白异常是如何被捕获的，必须首先理解**监控区域**(guarded region)的概念。它是一段可能产生异常的代码，并且后面跟着处理这些异常的代码。

### try块
如果在方法内部抛出了异常（或者在方法内部调用的其他方法抛出了异常），这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法内设置一个特殊的块来捕获异常。因为在这个块里“尝试”各种（可能产生异常的）方法调用，所以称为 try 块。它是跟在try关键字之后的普通程序块：
```java
try{
    // Code that might generate exceptions
}
```
### 异常处理程序
当然，抛出的异常必须在某处得到处理。这个“地点”就是**异常处理程序**，而且针对每个要捕获的异常，得准备相应的处理程序。异常处理紧跟在 try 块之后。以关键字 catch 表示：

```java
try{
    //Code that might generate exception
}catch(Type1 id1){
    //Handle exceptions of Type1
}catch(Type2 id2){
    //Handle exceptions of Type2
}catch(Type3 id3){
    //Handle exceptions of Type3
}
// etc...
```

每个 catch 子句（异常处理程序）看起来就像是接收一个且仅接收一个特殊类型的参数的方法。可以在处理程序的内部使用标识符，因为异常的类型已经给了你足够的信息来对异常进行处理，但标识符并不可以省略。

异常处理程序必须紧跟在 try 块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行。此时认为异常得到了处理。一旦 catch 子句结束，则处理程序的查找过程结束。注意，只有匹配的catch子句才能得到执行；这与 switch 语句不同，switch 语句需要在每一个 case 后面跟一个break，以避免执行后续的case子句。

注意在 try 块内部，许多不同的方法调用可能会产生类型相同的异常，而你只需要提供一个针对此类型的异常处理程序。
#### 终止与恢复

