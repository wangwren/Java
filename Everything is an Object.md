# 一切都是对象

> 如果我们说另一种不同的语言，那么我们就会发觉一个有些不同的世界

## 必须由你创建所有对象

### 存储到什么地方

- 寄存器
  - 这是最快的存储区，因为它位于不同于其他存储区的地方，即处理器内部。但是寄存器的数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象（另一方面，C和C++允许您向编译器建议寄存器的分配方式）。
- 堆栈
  - 位于通用RAM（随机访问存储器）中，但通过堆栈指针可以从处理器那里获得直接支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的确切生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以**某些**Java数据存储于堆栈中，特别是对象引用，但是Java**对象**并不存储于其中。
- 堆
  - 一种通用的内存池（也位于RAM区），用于存放**所有**Java对象。
  - 堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。
  - 因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配。
  - 当然，为这种灵活性必须要付出相应的代价：用堆进行存储分配和清理可能比用堆栈进行存储分配需要更多的时间。
- 常量存储
  - 常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。有时，在嵌入式系统中，常量本身会和其他部分隔离开，所以在这种情况下，可以选择将其存放在ROM（只读存储器）中。
  - ROM：这种存储区的一个例子是字符串池。所有字面常量字符串和具有字符串值得常量表达式都自动是内存限定的，并且会置于特殊的静态存储区中。
- 非RAM存储
  - 如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是**流对象**和**持久化对象**。
  - 在*流对象*中，对象转化成字节流，通常被发送给另一台机器。
  - 在*持久化对象*中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。
  - 这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象。
  - Java提供了对轻量级持久化的支持，而诸如JDBC和Hibernate这样的机制提供了更加复杂的对在数据库中存储和读取对象信息的支持。

#### 特例：基本类型

在程序设计中经常用到一系列类型，它们需要特殊对待。可以把它们想象成“基本”类型，之所以特殊对待，是因为`new`将对象存储在**堆**里，故用new创建一个对象，特别是小的、简单的变量，往往不是很有效。

因此，对于这些类型，Java采取与C和C++相同的方法。也就是说，不用new来创建变量、而是创建一个并非是引用的“自动”变量。这个变量直接存储**值**，并置于**堆栈**中，因此更加高效。

**Java要确定每种基本类型所占存储空间的大小。这种存储空间大小的不变性是Java程序比其他大多数语言编写的程序更具可移植性的原因之一。**

| 基本类型 | 大小   | 最小值    | 最大值           | 包装器类型 |
| :------: | ------ | --------- | ---------------- | ---------- |
| boolean  | -      | -         | -                | Boolean    |
|   char   | 16bit  | Unicode 0 | Unicode 2 ^16^-1 | Character  |
|   byte   | 8bits  | -128      | +127             | Byte       |
|  short   | 16bits | -2^15^    | +2^15^-1         | Short      |
|   int    | 32bits | -2^31^    | +2^31^-1         | Integer    |
|   long   | 64bits | -2^63^    | +2^63^-1         | Long       |
|  float   | 32bits | IEEE754   | IEEE754          | Float      |
|  double  | 64bits | IEEE754   | IEEE754          | Double     |
|   void   | -      | -         | -                | Void       |

- boolean类型所占存储空间的大小没有明确指定，仅定义为能够取字面值true或false
- 基本类型具有包装器类，使得可以在堆中创建一个非基本对象，用来表示对应的基本类型。

#### 高精度数字

Java提供了两个用于高精度计算的类：BigInteger和BigDecimal。虽然它们大体上属于“包装器类”的范畴，但二者都没有对应的基本类型。

能作用于int或float的操作，也同样能作用于BigInteger或BigDecimal。只不过必须以方法调用方式取代运算符方式来实现。这样做运算速度会比较慢，但是我们以时间换取了精度。

- BigInteger:支持任意精度的整数。也就是说，在运算中，可以精确地表示任何大小的整数值，而不会丢失任何信息。
- BigDecimal支持任何精度的定点数，例如，可以用它进行精确的货币计算。
- 具体使用可以查API。

#### Java中的数组

- 当创建一个数组**对象**时，实际上就是创建了一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字**null**。一旦Java看到null，就知道这个引用还没有**指向**某个对象，在使用任何引用前，**必须为其指定一个对象**；如果试图使用一个还是null的引用，在运行时将会报错。
- 还可以创建用来存放基本数据类型的数组。同样，编译器也能确保这种数组的初始化，因为它会将这种数组所占的内存全部置零。